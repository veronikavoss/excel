<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV 변환 도구 (일괄 처리)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Malgun Gothic", "맑은 고딕", helvetica, "Apple SD Gothic Neo", sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #container {
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            padding: 30px;
            width: 100%;
            max-width: 600px;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-top: 0;
        }
        
        /* [추가] 드래그 앤 드롭 영역 */
        #dropZone {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            background-color: #fafafa;
            transition: background-color 0.3s, border-color 0.3s;
        }
        #dropZone.dragover {
            background-color: #e8f0fe;
            border-color: #007bff;
        }
        #dropZone p {
            color: #666;
            font-size: 1.1rem;
            margin: 0 0 20px 0;
        }
        
        /* [추가] 버튼 그룹 */
        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .btn {
            padding: 12px 20px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #fileSelectBtn {
            background-color: #5c677d;
            color: white;
        }
        #fileSelectBtn:hover { background-color: #495366; }
        
        #folderSelectBtn {
            background-color: #5c677d;
            color: white;
        }
        #folderSelectBtn:hover { background-color: #495366; }

        /* [추가] 숨겨진 input 태그들 */
        .hidden-input {
            display: none;
        }
        
        /* 변환 버튼 */
        #convertButton {
            width: 100%;
            padding: 15px;
            margin-top: 25px;
            font-size: 1.1rem;
            background-color: #007bff;
            color: white;
        }
        #convertButton:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        /* 로그 */
        #log {
            margin-top: 20px;
            background-color: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 15px;
            font-family: "Courier New", Courier, monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 50px;
            font-size: 0.9rem;
            color: #444;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>CSV 매핑 툴 📑</h1>
        
        <div id="dropZone">
            <p>여기로 파일이나 폴더를 끌어다 놓으세요</p>
            <div class="button-group">
                <button type="button" id="fileSelectBtn" class="btn">📄 파일 선택</button>
                <button type="button" id="folderSelectBtn" class="btn">📁 폴더 선택</button>
            </div>
        </div>

        <input type="file" id="fileInput" class="hidden-input" accept=".csv" multiple>
        <input type="file" id="folderInput" class="hidden-input" webkitdirectory directory>

        <button id="convertButton" class="btn" disabled>변환 및 다운로드</button>

        <pre id="log">1. 파일이나 폴더를 선택/드롭하세요.</pre>
    </div>

    <script>
        const dropZone = document.getElementById('dropZone');
        const fileSelectBtn = document.getElementById('fileSelectBtn');
        const folderSelectBtn = document.getElementById('folderSelectBtn');
        const fileInput = document.getElementById('fileInput');
        const folderInput = document.getElementById('folderInput');
        const convertButton = document.getElementById('convertButton');
        const logEl = document.getElementById('log');

        let filesToProcess = []; // [수정] 처리할 파일 목록을 저장할 배열

        // --- 1. 입력 이벤트 핸들러 (버튼, 드래그 앤 드롭) ---

        // '파일 선택' 버튼 클릭
        fileSelectBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', () => {
            handleFileSelection(fileInput.files);
        });

        // '폴더 선택' 버튼 클릭
        folderSelectBtn.addEventListener('click', () => folderInput.click());
        folderInput.addEventListener('change', () => {
            handleFileSelection(folderInput.files);
        });

        // 드래그 앤 드롭 이벤트
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false); // 전체 화면 드롭 방지
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => dropZone.classList.add('dragover'), false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => dropZone.classList.remove('dragover'), false);
        });

        // 드롭 처리
        dropZone.addEventListener('drop', handleDrop, false);

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        async function handleDrop(e) {
            const items = e.dataTransfer.items;
            let files = [];

            if (items) {
                // [신규] 드롭된 항목(파일/폴더)을 비동기적으로 스캔
                const scanPromises = [];
                for (let i = 0; i < items.length; i++) {
                    const entry = items[i].webkitGetAsEntry();
                    if (entry) {
                        scanPromises.push(scanFileEntry(entry));
                    }
                }
                const nestedFiles = await Promise.all(scanPromises);
                files = nestedFiles.flat(Infinity); // 모든 중첩 배열을 1차원으로 펼침
            } else {
                // 폴더 스캔을 지원하지 않는 경우 (예: Firefox)
                files = Array.from(e.dataTransfer.files);
            }
            
            handleFileSelection(files);
        }
        
        // [신규] 파일/폴더 엔트리 스캔 (재귀)
        function scanFileEntry(entry) {
            return new Promise((resolve, reject) => {
                if (entry.isFile) {
                    entry.file(file => resolve(file), reject);
                } else if (entry.isDirectory) {
                    const reader = entry.createReader();
                    reader.readEntries(async (entries) => {
                        const results = await Promise.all(entries.map(scanFileEntry));
                        resolve(results.flat());
                    }, reject);
                } else {
                    resolve(null); // 알 수 없는 항목
                }
            });
        }
        
        // [신규] 파일 목록 처리 (공통 로직)
        function handleFileSelection(fileList) {
            // FileList나 배열을 File 객체의 배열로 변환
            filesToProcess = Array.from(fileList).filter(file => 
                file && file.name.toLowerCase().endsWith('.csv')
            );
            
            const fileCount = filesToProcess.length;
            
            if (fileCount > 0) {
                log(`[${fileCount}개 CSV 파일]이 선택되었습니다.\n\n- ${filesToProcess.map(f => f.name).slice(0,10).join('\n- ')}\n${fileCount > 10 ? '... 외 다수' : ''}\n\n'변환' 버튼을 누르세요.`);
                convertButton.disabled = false;
            } else {
                log('🔴 선택된 파일/폴더 중에 처리할 `.csv` 파일이 없습니다.');
                convertButton.disabled = true;
            }
        }

        // --- 2. 변환 로직 ---

        convertButton.addEventListener('click', runConversion);

        async function runConversion() {
            if (filesToProcess.length === 0) {
                log('🔴 오류: 변환할 파일이 없습니다.');
                return;
            }

            log(`🔄 총 ${filesToProcess.length}개 파일 처리 중...`);
            convertButton.disabled = true;

            try {
                const zip = new JSZip();
                let csvFileCount = 0;
                
                for (const file of filesToProcess) {
                    try {
                        log(`... '${file.name}' 파일 변환 중 ...`);
                        const text = await readFileAsText(file);
                        const convertedCsv = processCSV(text);
                        const newFileName = `표준서식_${file.name}`;
                        
                        const bom = '\uFEFF'; // UTF-8 BOM
                        zip.file(newFileName, bom + convertedCsv);
                        csvFileCount++;
                    } catch (fileError) {
                        log(`🔴 '${file.name}' 처리 중 오류: ${fileError.message}`);
                    }
                }

                if (csvFileCount > 0) {
                    log(`🔄 ${csvFileCount}개 CSV 파일 변환 완료. ZIP 파일 생성 중...`);
                    const zipBlob = await zip.generateAsync({ type: "blob" });
                    downloadBlob(zipBlob, '표준서식_일괄변환.zip');
                    log(`✅ ${csvFileCount}개 파일 일괄 변환 완료! '표준서식_일괄변환.zip' 파일이 다운로드됩니다.`);
                } else {
                    log('🔴 변환에 성공한 CSV 파일이 없습니다.');
                }

            } catch (error) {
                log(`🔴 전체 변환 중 오류 발생: ${error.message}`);
                console.error(error);
            } finally {
                convertButton.disabled = false;
                // [수정] 작업 완료 후 파일 목록 초기화
                filesToProcess = [];
                // 입력 필드 값 초기화 (다음에 같은 파일/폴더를 또 선택할 수 있도록)
                fileInput.value = null;
                folderInput.value = null;
            }
        }
        
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsText(file, 'UTF-8'); // UTF-8로 읽기
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(new Error(`'${file.name}' 파일 읽기 실패`));
            });
        }
        
        /**
         * [ 중요! 맞춤 설정 영역 ]
         * 원본 '업종'을 '계정과목'으로 변환하는 규칙입니다.
         */
        function getAccountTitle(category) {
            if (category.includes('마트') || category.includes('잡화점') || category.includes('편의점')) {
                return '소모품비';
            }
            if (category.includes('한식') || category.includes('음료') || category.includes('커피')) {
                return '복리후생비';
            }
            if (category.includes('통신비')) {
                return '통신비';
            }
            return '잡비'; // 기본값
        }

        // CSV 처리 로직
        function processCSV(csvText) {
            const lines = csvText.split(/\r?\n/);
            
            if (lines.length < 2) throw new Error('데이터가 비어있거나 헤더만 존재합니다.');

            const rawHeaderLine = lines[0].trim();
            const rawHeaders = rawHeaderLine.split(',').map(h => h.replace(/"/g, ''));

            const colIndex = {
                성명: rawHeaders.indexOf('성명'),
                카드번호: rawHeaders.indexOf('카드번호'),
                이용일: rawHeaders.indexOf('이용일'),
                '이용금액(원)': rawHeaders.indexOf('이용금액(원)'),
                가맹점명: rawHeaders.indexOf('가맹점명'),
                업종: rawHeaders.indexOf('업종')
            };

            for (const key in colIndex) {
                if (colIndex[key] === -1) {
                    throw new Error(`필수 열을 찾을 수 없습니다: '${key}'`);
                }
            }
            
            const outputHeader = [
                "년도월일   (숫자8)", "구 분  (숫자1)", "코드", "계정과목", "거래처코드",
                "\"거 래 처 명\n(30자리)\"", "적요코드", "적  요  명", " 금    액",
                "\"부서명\n(15자리)\"", "\"사원명\n(15자리)\"", "현장구분", "\"현장\n코드\"",
                "\"현 장 명\n(25자리)\"", "거래처구분", "\"등록,계좌,카드번호\"",
                "\"업   태\n(20자리)\"", "\"종    목\n(30자리)\"", "우편번호",
                "\"주  소\n(80자리)\"", "\"상  세  주  소\n(80자리)\"", "대표자",
                "매입카드일때카드유형", "신용카드사코드", "\"카드사용\n여부\"",
                "\"프로젝트\n코드\"", "\" 프로젝트명\n(30자리)\"", "\" 증빙불비 원인\n(30자리)\""
            ].join(',');

            const outputRows = [outputHeader];

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === "") continue;

                const cols = line.split(',');
                if (cols.length < rawHeaders.length) continue;

                const rawDate = cols[colIndex.이용일];
                const rawCategory = cols[colIndex.업종];
                const rawStoreName = cols[colIndex.가맹점명];
                const rawAmount = cols[colIndex['이용금액(원)']];
                const rawName = cols[colIndex.성명]; // '성명' 원본 값
                const rawCardNum = cols[colIndex.카드번호];

                if (!rawDate) continue; // 이용일이 없는 빈 줄 방지

                const newDate = rawDate.replace(/-/g, '');
                const accountTitle = getAccountTitle(rawCategory);
                const newCardNum = rawCardNum.replace('**', '-');
                
                let newRow = new Array(28).fill('');

                newRow[0] = newDate;
                newRow[1] = '3';
                newRow[3] = accountTitle;
                newRow[5] = rawStoreName;
                newRow[7] = rawStoreName;
                newRow[8] = rawAmount;
                newRow[10] = rawName; // '성명' 원본값 사용
                newRow[15] = newCardNum;
                newRow[16] = rawCategory;
                newRow[17] = rawCategory;
                newRow[22] = '삼성카드';
                newRow[23] = '삼성카드';
                newRow[24] = '1';

                outputRows.push(newRow.join(','));
            }
            
            if (outputRows.length <= 1) throw new Error('처리할 데이터 행이 없습니다.');
            
            return outputRows.join('\n');
        }

        // Blob 다운로드 헬퍼
        function downloadBlob(blob, fileName) {
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', fileName);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

    </script>
</body>
</html>